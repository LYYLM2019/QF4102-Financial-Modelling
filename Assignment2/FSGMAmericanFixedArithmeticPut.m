function optValue = FSGMAmericanFixedArithmeticPut(t, T, S0, sigma, q, runningAvg, r, K, rho, N)  %% Meaning of the parameters of this function % t: time elapsed measured in years % T: the total time to maturity from initiation % S0: the current underlier price % sigma: the underlier's volatility % q: the underlier's dividend yield % runningAvg: The previous running average % r: the market's risk free rate % K: the fixed strike price for this option % rho: the FSGM parameter % N: the number of time periods in lattice  %% Initial set up of parameters  dt = (T-t)/N; m = 1/rho; % the reciprocal of paramter rho dx = sigma * sqrt(dt); dy = rho * dx; u = exp(dx); d = exp(-dx); p = (exp((r-q)*dt) - d) / (u-d);  elapsedPeriods = t / dt; currentPeriods = elapsedPeriods + 1; runningAvg = (runningAvg * elapsedPeriods + S0) / currentPeriods;  Average = zeros(2*N*m+1, 1);  jshift = 1; kshift = N*m + 1;  for k = (-N*m):1:(N*m)    Average(k + kshift) = runningAvg * exp(k*dy); end  %% Initialization V = zeros(N+1, 2*N*m+1); % j, k one dimensional matrix for k = (-N*m):1:(N*m)    V(N+jshift, k+kshift) = max((K - Average(k+kshift)), 0); end  %% Algorithm: backward iteration for n = (N-1):-1:0    Vtemp = zeros(n+1, 2*n*m+1); % the current option value storage    for j = 0:1:n % for different price states-----                S = S0 * exp((2 * j - n) * dx); %current price state        nl = n + currentPeriods; %current number of periods for calculating average                for k = (-n*m):1:(n*m) % for different average (1 line below)------                        A = Average(k+N*m+1); % current running average                         % up branch====== j+1 is used            Aup = (S * u + nl * A) / (nl + 1); % up branch average            kfloor = floor(log(Aup / runningAvg) / dy); % get the closest index                        kfloor_index = max(kfloor + (n+1)*m + 1, 1); % indexing for matrix V                        average_index = kfloor + kshift; % indexing for average vector            Vup_floor = V(j+1+jshift, kfloor_index);            Vup_floor_p1 = V(j+1+jshift, kfloor_index + 1);            Vup = LinearInterpolate(Aup, Average(average_index), Average(average_index + 1), Vup_floor, Vup_floor_p1);                        % down branch====== j is used            Adown = (S * d + nl * A) / (nl + 1);            kfloor = floor(log(Adown / runningAvg) / dy);                         kfloor_index = max(kfloor +(n+1)*m + 1, 1); % indexing for matrix V                        average_index = kfloor + kshift; % indexing for average vector            Vdown_floor = V(j+jshift, kfloor_index);            Vdown_floor_p1 = V(j+jshift, kfloor_index + 1);            Vdown = LinearInterpolate(Adown, Average(average_index), Average(average_index + 1), Vdown_floor, Vdown_floor_p1);                        % update V vector for current j (price states) and k (current average)            Vtemp( j+jshift, k+(n*m)+1 ) = max(exp(-r * dt) * (p * Vup + (1 - p) * Vdown),  (K-A));                    end    end    V = Vtemp; end  optValue = max(V(1,1), (K-runningAvg)); endfunction sol = LinearInterpolate(x, x0, x1, f0, f1)  sol = (x - x1) / (x0 - x1) * f0 + (x - x0) / (x1 - x0) * f1;end